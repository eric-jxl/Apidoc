# 交接文档



### 预算

Moudule:rh_account_budget

1.`conf`

 	存放redis配置文件

2.`contrlollers`

​	==main.py==  class SyncBudgetReport:

​	Route:/api/get_crossovered_budget  : 预算汇总情况  返回:`json`

​	Route:/api/get_account_budget_post: 预算状况汇总表

3.`lib`

​	==jwt_utils.py== :封装接口加密机制

​	 

```python
def sha256base64
#密钥加密算法
def verify_token
#校验token装饰器
```

​	 ==redislib.py== ：封装了所有redis的连接池和接口

```python
class ExportRedis:
    def insert_redis_queue(self, queue, params_dict):
        '''由左向右👉插入List'''
        self.cursor.lpush(queue, json.dumps(params_dict))

    def rpop_redis_queue(self, queue):
        '''从右向左弹出 return []'''
        return self.cursor.rpop(queue)
    
    def range_queue(self, queue):
        # 查询列表中所有的键值
        return self.cursor.lrange(queue, 0, -1)
```



4. `Models`

    ==account_budget_modify.py==:主要功能点：表：==crossovered.budget.lines==预算明细表

    planned_amount  计划金额 practical_amount 实际金额  ==new_practical_amount==  根据practical_amount实际金额write回填    balance 余额。show_color ：控制列表变红

    done_per 完成率 

    ==def _compute_practical_amount== 计算实际金额，根据分析账户明细中 该分析账户在日期区间内有的`预算状况` 进行SUM计算

    

    ==budget_hr_expense.py== ：继承hr.expense.sheet 对费用单据进行预算超支`预警弹出框`,在do_sumbit和do_approved 取预算的余额和当前在待批和完成的单据发生额进行比较，==超的明细行变红并且弹出提示框==

    ```python
    class HrExpense
    module_budget_installed #检查预算模块是否安装，有分析账户必填
    excess_color  #计算字段 compute_excess_color
    	def compute_module_budget_installed(self):
            for record in self:
                module = self.env['ir.module.module'].sudo().search([('name', '=', 		'rh_account_budget')])
                if record.payment_mode == 'own_account': #属于报销类型
                  #  下面根据情况分预算内/预算外
                else: #自动扣款
                    record.module_budget_installed = False
         
    	def  compute_excess_color #控制明细行变红
        
        def action_to_analytic_form：#跳转到对应的分析账户界面
        
        def edit_expense_line_analytic :#修改分析账户上analytic_account_id
            
    ```

    ==inherit_analytic_account.py== ：对分析账户功能继承

    ​	`department_ids`：部门  `user_ids`：员工    `department_user_ids`：部门下的员工

    ​	根据部门选择下属员工可见，或者直接选择员工，限制记录规则

    ​	def compute_user_ids :计算部门的员工

    ```python
    #重写分组函数。用来计算预算的实际金额、占用金额、余额
    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
            res = super(AccountAnalyticAccount, self).read_group(domain, fields, groupby, offset=offset, limit=limit,
                                                                 orderby=orderby, lazy=lazy)
            for r in res:
                domain = r.get('__domain', [])
                records = self.search(domain)
                r['budget_planned_amount'] = sum(records.mapped('budget_planned_amount')) or 0.0
                r['budget_amount'] = sum(records.mapped('budget_amount')) or 0.0
                r['budget_balance'] = sum(records.mapped('budget_balance')) or 0.0
                r['occupy_amount'] = sum(records.mapped('occupy_amount')) or 0.0 #占用金额
    
            return res
        
    def summary_analytic_records(self): #计算该分析账户关联的费用单据的发生额
    def click_details_windows(self):#跳转按钮，嵌套上面的方法，每次点击删除旧纪录，生成新纪录，筛选当前的分析账户
    ```

    ​	

    

5. `wizard`

    临时表提供向导功能

    ==wizard_analysis_examine_details.py== 分析账户使用的详情

    ==wizard_batch_dept_users.py==:更新部门下的员工

    ==wizard_edit_expense_line_analytic.py==：修改分析账户明细行

    ==wizard_hr_expense_sheet_budget.py==:费用审批和提交。判断是否超支金蝶





### 金蝶

`Module`:rh_kingdee_port

1. Data:`kingdee_ir_corn.xml`：定时任务：`费用单据推送账无忧`,`收付款单据推送账无忧`,`内部转账单据推送账无忧`

    `kingdee_setting.yml`：自动创建金蝶配置参数

  2.Lib：

​		`redislib.py`: def handle_redis_token存储设置token的有效时长为4小时，过期自动删除

​	3.Models:

​		==rh_kingdee_port.py==集成金蝶所有模型和接口

​		==rh_kingdee_send_logs.py==：金蝶同步日志

​		==account_payment_interface.py==：集成收付款推送功能

​		==inhert_hr_sheet.py==：费用推送

​		==rh_inherit_company.py==：输入公司名称，获取帐无忧对应的客户编号用于同步接口

​		==rh_kingdee_category.py==：金蝶票据类型和凭证模版存放的模型表

​		`金蝶配置`是通过yaml文件导入生成的

​	4.`wizard`

​		push_account_sheet_wizard.py ：费用推送向导

​		push_expense_sheet_wizard.py：收付款向导

```python
class Kingdee_Port_set(models.Model):
    def test_kingdee_connection(self):#测试链接并将token保存到redis当中
    def check_redis_token(self) #检查toke能有效性，有则获取，无则重新调用test_kingdee_connection
    def get_kingdee_category(self)#获取票据类型
    def get_account_rule(self):#获取凭证模版
    def batch_push_documents(self):#推送单据到帐无忧智能记账
    def get_report_account(self):#获取银行科目
    
```



### 百度行政编吗

​	1.`Models`:address_maintenance.py

​		调取APi接口，分别为省、市、区、乡镇街道(目前只有北京和上海)写入名称和行政编吗

​	2.`Views`:address_import.xml

​		限制原模型的创建修改



### 短信平台

​	1.`Models`:compressed_link.py

​		大汉三通短链接 def set_short_url

​		inherit_workflow_config_settings.py 继承基础配置模型，写入短信URL，账号、密码

​		send_message.py ：短信模版和接口调用

### 自由签

1.`Models`

​	`Fields`:sign_process_id :签署流程ID，signatory_ids：签署方列表，current_signatory_id：当前签署人，

​	history_signatory_id：发起签署的人（第一）

- ==free_sale.py==:电子签约添加签署方 

```python
def init_send_sign_msg(self):#当前签署人必须是企业当前签署人，初始化签署的环境，`多签`必须法人确认短信，`单签`无需确认
    if party_partner_obj.org_id.id != False: #代表企业签署
        if sign_partner_obj.id != legal_person_partner_obj.id: #当前签署人不是法人
            flag = True
            if signing_method == 'multi_signature': #多签
                party_obj.auth_state = 'start_auth'
                result = tool.send_msg_to_legal_person_for_sign(model_str, record_id, party_obj.id,time_stamp, sign_partner_obj.id)
    else:
        party_obj.auth_state = 'person' #个人签署
                                                                

def send_sign_msg(self):#发起签约调用e签宝静默签署	 
                   flow_num,body_json=util.util_send_sale_signature(data,name,sign_list,'sign_free_sale',model='free.sale',record_id=self.id) #构造签署方列表所需的环境变量
        field_list = handler.find_sign_field_based_on_flow_num(flow_num=flow_num,lighthouse=lighthouse)
        
```



- ==def send_sign_msg==：为自由签分类为，单签和多签，在XML context中默认`def create_signer`单签自动带出当前公司的当前签署人，`def action_opt_sign_warning`没有签署人弹出提醒 ，`def do_submit`直接创建签署方，`notify_signer_msg`:走完审批流发送短信

- `single_sign.py`: 字段：signing_method ：【'single_sign':单签，'multi_signature':多签】

     `def create_signer`:单签自动创建签署方列表方法

    `def _compute_belong_singer`:根据current_signatory_id,判断当前签署人和登录id是否一致

- `free_sign_popup_reminder.py`:签署方列表为空时，弹出向导的wizard方法

2.`Controllers`

​	==controllers.py==: `/sign/process/free_sale`这个路由是用来自由签署回调，更改本地的状态

